[{"content":"༺https://aistudio.google.com/prompts/111ysUKgf9_PR3y4WpkPTJiuEsCHn5DcG ༻\npart1: 独立开发者穷鬼套餐介绍 (0:00-0:06) 1.1: 论坛热门话题：独立开发者穷鬼套餐 视频开头提到，在技术论坛中经常看到一个有趣的话题，即**\u0026ldquo;独立开发者省钱之穷鬼套餐\u0026rdquo;**。\n(0:06-0:13) 1.2: 穷鬼套餐覆盖范围 这些免费工具涵盖了开发、代码托管、前后端部署、数据库以及用户行为分析等一系列功能。\n(0:13-0:17) 1.3: 适用人群 这种套餐尤其适合学生党、独立开发者以及初创公司。\n(0:17-0:24) 1.4: 零成本启动与迭代 开发者可以利用这些免费工具，零成本做出产品并发布上线，等到开始盈利以后再慢慢迭代扩容。\n(0:24-0:34) 1.5: 本期视频目标 本期视频准备用一个小项目（贪吃蛇游戏）把这些免费的工具全部串联起来，展示如何不花一分钱就能上线一个可以赚钱的业务应用。\npart2: 技术选型 (0:34-0:40) 2.1: 后端部署成本最低方案：Node.js 作者认为，对于后端，部署成本最低的方案是 Node.js。\n(0:40-0:51) 2.2: Node.js 优势：Serverless Function 原因是 ♋Node.js 可以很轻松地改造成 Serverless Function（无服务器函数）。现在很多平台提供免费的云函数部署服务，♐例如 Cloudflare Worker、Vercel 和 Netlify 等。\n(0:51-0:56) 2.3: 前端选型：影响不大 对于前端选型，作者认为其对于部署成本几乎没有影响，选择自己喜欢的就好。\n(0:56-1:04) 2.4: 前端推荐：React 与 React Native 推荐使用 React，因为后续还可以使用 React Native 改造成跨端的手机应用。\n(1:04-1:10) 2.5: ♈框架选择：Next.js ♋结合后端 Node.js 和前端 React，很自然会想到 Next.js，这是一个在海外十分流行的开发框架。\n(1:10-1:18) 2.6: Next.js 优势：SEO 友好 Next.js 具有 SEO 友好的特点，使得网站更容易被搜索引擎收录。它结合了客户端（Client）渲染和服务器端（Server）渲染（SSR/Static HTML）的能力。\n(1:18-1:24) 2.7: 本期项目选择与 AI 辅助 本期视频决定使用 Next.js 来搭建工程。由于作者对 Next.js 不太熟悉，计划将主要的开发任务交给 AI 来完成。\npart3: AI开发工具与项目初始化 (1:24-1:35) 3.1: 推荐免费AI编程方案 (VSCode + Cline + OpenRouter) 推荐一个完全免费的 AI 编程方案：在 VS Code 上使用 Cline 插件，并接入 OpenRouter 的免费 API，以达到非常好的 AI 编程效果。\n(1:35-1:44) 3.2: 安装VSCode 首先访问 code.visualstudio.com，下载并安装 VS Code。安装过程十分简单，一路点击下一步即可。\n(1:44-1:47) 3.3: VSCode 基础使用参考 作者提到之前有一个完整视频介绍 VS Code 的使用。\n(1:47-1:56) 3.4: 安装与配置Cline插件 进入 VS Code 后，在扩展市场搜索 Cline 插件，点击 Install 进行安装。\n(1:56-2:05) 3.5: 获取 OpenRouter API Key 打开 Cline 插件界面，选择 \u0026ldquo;Use your own API key\u0026rdquo;，API Provider 选择 OpenRouter，然后点击 \u0026ldquo;Get OpenRouter API Key\u0026rdquo; 按钮。\n(2:05-2:10) 3.6: OpenRouter授权 跳转到 OpenRouter 网站进行授权（该网站在国内可以直连），如果没有账号需要先注册。点击 Authorize。\n(2:10-2:23) 3.7: 完成Cline模型选择 (DeepSeek) 回到 VS Code，点击 Open 允许插件打开 URI。这样 OpenRouter API key 就配置好了。在 Model 选择处，搜索并选择免费的 DeepSeek free 模型（deepseek/deepseek-chat-v3-0324-free）。AI 编程软件配置完成。\n(2:23-2:30) 3.8: 安装Node.js ♈访问 Node.js 官网 (nodejs.org)，下载并安装 Node.js（LTS 版本）。安装过程同样是一路点击下一步。\n(2:30-2:54) 3.9: ♈ 创建Next.js项目 (Snake) ♓安装完 Node.js 后，♓重启 VS Code。打开一个新的终端（Terminal），切换到目标项目文件夹（例如 D:\\Project2025）。♋输入命令 npx create-next-app 并按回车。\n项目命名： 输入 snake（贪吃蛇）。 配置选项： 对于 TypeScript, ESLint, Tailwind CSS, src/ directory, App Router, import alias 等选项，♋全部一路回车使用默认配置。 (2:54-3:06) 3.10: 启动初始Next.js项目 项目创建成功后，使用 VS Code 打开新创建的 snake 目录，点击信任。♋在终端中输入 npm run dev 启动项目。♋浏览器访问 http://localhost:3000，可以看到一个空白的 Next.js 工程已成功运行。\n(3:07-3:18) 3.11: 使用Cline生成贪吃蛇游戏页面 接下来，准备使用AI工具（Cline）将Next.js的初始页面改造。\n目标： 将页面改造成一个贪吃蛇的网页小游戏。 操作： 在Cline中输入改造需求的prompt。（♋⌊把这个项目⌋改造成一个含吃蛇的网页版小游戏。） 结果： AI（Cline）成功生成了贪吃蛇游戏的代码，并在浏览器中演示了基本的游戏界面。 part4: 代码管理 (3:18-3:24) 4.1: 个人开发者代码管理最佳选择：GitHub 对于个人开发者来说，代码管理的最佳选择是 GitHub。\n(3:24-3:38) 4.2: GitHub 功能与优势 GitHub 是全球最大的代码仓库托管与协作平台，可以在其中存储、分享并与他人一起编写代码。它支持创建私有（private）仓库，只有自己和被授权的协作者可以访问，不用担心源代码泄露。\n(3:38-3:50) 4.3: 解决GitHub访问慢的问题 如果访问 GitHub 速度很慢，可以在搜索栏搜索\u0026quot;商店\u0026quot;，来到微软的应用商店（Microsoft Store），下载 Watt Toolkit 这个工具。\n(3:50-3:53) 4.4: GitHub 账号注册 如果没有 GitHub 账号，需要先注册一个。\n(3:53-4:07) 4.5: 安装 Git 为了将 Next.js 工程上传到 GitHub，需要先安装 Git。在 VS Code 的源代码管理（Source Control）面板，点击 \u0026ldquo;Download Git for Windows\u0026rdquo; 按钮，跳转到下载页面。下载 64 位的安装包并安装，安装过程同样是一路点击下一步。\n(4:07-4:18) 4.6: 配置 Git 并发布到 GitHub 安装完 Git 后，在 VS Code 终端中配置 Git 用户名和邮箱： git config --global user.name \u0026quot;your_username\u0026quot; git config --global user.email \u0026quot;your_email@example.com\u0026quot; 然后，在 VS Code 的源代码管理面板♋点击 \u0026ldquo;Publish Branch\u0026rdquo; 按钮。选择 \u0026ldquo;Publish to GitHub private repository\u0026rdquo;♋⌊将代码发⌋ 布为私有仓库。\n(4:18-4:23) 4.7: 确认代码备份 现在，项目代码已经提交备份到 GitHub 上面了，拥有了一个远程的 Git 仓库。\npart5: 数据库 (4:23-4:33) 5.1: 免费数据库服务推荐：Neon 与 Supabase 对于免费的数据库服务，这里推荐两个：Neon 和 Supabase。它们都提供 500 MB 的免费存储空间。本视频选择使用 Neon。\n(4:33-4:46) 5.2: 创建 Neon 数据库 来到 Neon 的官网 (neon.tech)，♋点击 \u0026ldquo;Start for free\u0026rdquo;。选择使用 GitHub 登录。\n数据库配置： Neon 是基于 PostgreSQL 的免费数据库。进入后，选择 PostgreSQL 版本（如 17），给 Project name 起个名字（如 tech-shrimp-db）。 结果： 瞬间就拥有了自己的免费数据库。 (4:46-4:50) 5.3: 查看数据库连接信息 在 Neon 的 ♈Project Dashboard，♋点击右上角的 Connect 按钮，可以查看数据库连接的相关信息（如连接字符串、用户名、密码、主机地址、数据库名）。\npart6: 数据库工具与集成 (4:50-4:57) 6.1: 数据库管理工具推荐：DBeaver 推荐使用开源免费的数据库管理工具 DBeaver。先来到其官网 (dbeaver.io)，下载 DBeaver Community 版本。\n(4:57-5:20) 6.2: ♈连接 DBeaver 到 Neon 数据库 打开 DBeaver 软件，新建数据库连接。\n选择数据库类型： 选择 PostgreSQL。 填写连接信息： 回到 Neon 的♎connect连接信息界面，将对应的主机（Host）地址、数据库（Database）名、用户（User）名、密码（Password） 复制并粘贴到 DBeaver 的相应字段中。 测试连接： 点击 \u0026ldquo;测试连接\u0026rdquo;。DBeaver 会自动下载 PostgreSQL 驱动。 结果： 连接成功。点击完成。 (5:20-5:35) 6.3: 在 DBeaver 中创建数据表 在 DBeaver 左侧导航栏可以打开数据库。♋接下来准备创建一个表，用来保存玩家分数，做一个分数排行榜。\n操作： 在 public 模式下的**表（Tables）**上右键，选择 \u0026ldquo;新建 表\u0026rdquo;。 表结构： 表名： player_score 列： 添加两列：player_name (类型 varchar) 和 score (类型 int)。 保存： 按 Ctrl+S 保存，点击执行（Persist）。 (5:35-5:58) 6.4: ♎使用 AI (Cline) 生成数据库操作代码 在 DBeaver 中右键点击刚创建的♈ player_score 表，选择 \u0026ldquo;生成 SQL\u0026rdquo; -\u0026gt; DDL，♐复制 CREATE TABLE 语句。\nPrompt 构建： ♐回到 VS Code 的 Cline，粘贴 CREATE TABLE 语句，并提出需求： ♐请把玩家的数据保存到 PostgreSQL 数据库里面，以下是建表语句。 ♋游戏开始前弄一个输入框，让玩家自己填名字。 (5:58-6:10) 6.5: 向 AI 提供数据库连接信息 ♈⌊AI（Cline） 询问 ⌋PostgreSQL 数据库的连接信息。回到 Neon 复制完整的连接字符串（Connection string）。 ♈它的主要目的是获取这些信息，以便生成正确配置的、能够连接数据库的应用程序代码 ♋因为它需要这些信息来生成正确的应用程序代码 (6:10-6:16) 6.6: AI 生成代码并测试 将连接字符串粘贴给 AI（Cline）。AI 修改了代码。点击 Save 保存更改。在终端运行 npm run dev 启动项目进行测试。\n(6:16-6:41) 6.7: 发现并分析错误 启动时出现构建错误：Module not found: Can't resolve 'dns'。\n定位原因： 查看 AI 写的代码，发现 page.tsx（前端页面）直接 import 并调用了 lib/db.ts 中的 saveScore 方法。而 saveScore 方法内部使用了 pg 包进行数据库连接和操作 (await pool.connect(), client.query())，并读取了环境变量 process.env.DATABASE_URL。 问题分析： Next.js 默认会将 page.tsx 作为前端组件处理。在前端（浏览器）环境中直接调用包含后端数据库操作（需要 pg 包）和敏感信息（数据库连接字符串）的代码是错误的，并且存在严重的安全隐患，会导致敏感信息暴露。 (6:41-6:56) 6.8: 向 AI 反馈错误并寻求解决方案 与 AI（Cline） 交流，指出保存数据库的逻辑似乎不正常，询问♒⌊保存数据库这块的逻辑正常么？这是后台操作还是前端操作？⌋，♒AI肯定没有意识到自己的错误，让 AI 检查其生成的代码，特别是 db.ts 和 page.tsx。\n(6:56-7:04) 6.9: AI 提出正确解决方案 (API Route) AI（Cline） 识别到错误，并提出了正确的解决方案：\n创建 API 路由： 新建一个 API 端点（例如 /api/saveScore）。 前后端分离： 前端页面通过发送 POST 请求到这个 API 端点来触发后端的数据库保存操作。 (7:04-7:19) 7.1: 更简洁的 Next.js 解决方案 (use server) 作者指出，其实还有一种更简单的 Next.js 改法：\n在 lib/db.ts 文件的顶部加上一行 'use server'; 指令。 作用： 这会告诉 Next.js，这个文件里的函数是服务器端的 Action。♋Next.js 会自动处理，♐生成相应的 API 端点，♋将前后端的逻辑分割开，无需手动创建 API 路由。 (7:19-7:51) 7.2: 对 AI 编程能力的思考 这个例子体现了作者对 AI 编程的看法：\nAI 的角色： 现阶段的 AI 水平相当于一个知识面广的初级程序员。 人类的角色： 人类依旧是高级程序员、项目架构师，需要负责系统架构设计、理解编程原理（如♈前后端交互、保护安全信息等系统架构的知识）。 协作方式： 不能完全依赖 AI，人类需要审查和指导 AI 的工作，将更多精力投入到架构设计和业务需求理解上。作为人类，掌握系统架构、编程原理等知识仍然是必学必会的。 part7: 部署 (7:51-8:00) 8.1: Next.js 项目最佳部署平台：Vercel 作为一个 Next.js 项目，最方便的部署方式就是部署到 Vercel 里面，♋因为 Vercel 目前是 Next.js 的母公司。\n(8:00-8:08) 8.2: 开始 Vercel 部署流程 来到 Vercel 官网 (vercel.com)，♋点击 \u0026ldquo;Start Deploying\u0026rdquo;。选择 Continue with GitHub 登录。♈选择之前创建的 snake GitHub 仓库，点击 Import。\n(8:08-8:18) 8.3: 配置环境变量并部署 项目设置基本保持默认。♐唯一需要修改的是在 Environment Variables（环境变量） 中添加数据库连接信息。\nKey: DATABASE_URL Value: 粘贴从 Neon 获取的连接字符串。 点击 Deploy 开始部署。 (8:18-8:32) 8.4: 部署完成与访问 等待大约 1 分钟左右，项目就部署完成了。点击 \u0026ldquo;Continue to Dashboard\u0026rdquo;。Vercel 会分配一个默认域名（例如 snake-bice-three.vercel.app）。\n测试： 访问该域名，功能与本地一致，可以正常游戏并保存分数到 Neon 数据库。 ♋注意： Vercel 的默认域名♋只能在国外的上网环境访问到。 (8:32-8:45) 8.5: Vercel 免费额度限制 在♋ Vercel 的 Dashboard -\u0026gt; Usage 页面，♈可以看到免费用户的用量限制。作者认为 Edge Requests（每月 100 万次）可能比较瓶颈。如果升级到 Pro 模式，这些用量限制可以提高 10 倍。\npart8: 域名 (8:45-8:55) 9.1: 域名的重要性与选择 域名作为一个产品的排面，不建议用免费的，因为不稳定且非常折腾。\n(8:55-9:05) 9.2: 推荐廉价域名注册商：NameSilo 可以来到 NameSilo (namesilo.com) 这个地址，以最低成本获得一个域名。\n示例： 搜索一个6 位数字，发现 6位数字.xyz 的域名只需要 0.99 美元一年。 (9:05-9:18) 9.3: 使用 Cloudflare 托管域名 有了域名以后，可以把它♐托管到 Cloudflare 上面。作者提到，关于如何把域名托管到 Cloudflare，在之前的视频里有过详细介绍，这里不再赘述。\n(9:18-9:34) 9.4: Vercel 绑定自定义域名 回到 Vercel 的项目♋设置（Settings） -\u0026gt; Domains 页面，点击 Add。\n输入域名： 输入自己购买并托管到 Cloudflare 的域名（或子域名），♋例如 snake.tech-shrimp.com。 自动配置： 点击 Add 后，♋选择 Configure Automatically。Vercel 会自动通过 Cloudflare API 配置 DNS 记录。 (9:34-9:40) 9.5: 测试自定义域名 配置完成后，页面上会显示两个蓝色的对勾，表示配置完成。使用这个自定义域名（snake.tech-shrimp.com）同样可以访问到刚才部署的网站，并且♉这个域名在国内是可以直连的。\npart9: 用户行为分析 (9:40-9:51) 10.1: 免费用户行为监控工具：Microsoft Clarity 推荐使用 Microsoft Clarity (clarity.microsoft.com)，这是微软推出的免费用户行为监控工具。它提供了热点地图（Heatmaps）、♈用户行为录像（Session Recordings）、**报表（Dashboard）**等一系列功能。\n(9:51-10:02) 10.2: 集成 Clarity 到 Next.js 项目 登录 Clarity（可以使用 Google 账号）。♋在 Clarity 项目设置中，♉选择手动安装（Manual install），♈获取跟踪代码（Tracking Code）。\n操作： 回到 VS Code，打开 ♋⌊app/layout.tsx 文件⌋。在 \u0026lt;body\u0026gt; 标签内，定义一个 \u0026lt;Script\u0026gt; 组件（从 next/script 导入），。将 Clarity 的跟踪代码粘贴到 \u0026lt;Script\u0026gt; 组件内部。 (10:02-10:10) 10.3: 验证 Clarity 集成 保存 layout.tsx 文件。在本地重新启动项目 (npm run dev) 并进行一些操作。♈回到 Clarity 网站，在录制（Recordings）页面，♐可以看到作为用户的操作已经被录制下来了。\n(10:10-10:17) 10.4: Clarity 其他功能说明 Clarity 的仪表板（Dashboard）和热点地图（Heatmaps）需要过 24 小时才能呈现数据。至此，♉已将网站轻松接入了 Clarity。\npart10: 邮件 (10:17-10:39) 11.1: 免费邮件收发方案 作者之前有一期视频介绍如何使用 Cloudflare 获取无限多个免费邮箱。\n收邮件： 主要使用 **Cloudflare 的电子邮箱路由（Email Routing）**功能。 ♉发邮件「白Cloudflare无限多企业邮箱，可收发邮件」： 借助 Resend (resend.com) 的免费 API。Resend 的免费套餐每天可以发送 100 封邮件，每个月最多 3000 封。 说明： 详细用法在之前的视频里，本期不再赘述。 part11: DDoS 防御 (10:39-10:55) 12.1: 免费 DDoS 防御方案 之前也有一期完整视频介绍使用 Cloudflare 防御 DDoS 攻击。\n主要方法： 配置 CDN。 配置 IP 白名单。 使用 Cloudflare 防火墙（Firewall）。 说明： 这三种方法可以有效防御 DDoS 攻击，详细内容在那期视频里，这里不再赘述。 part12: 其他免费工具与总结 (10:55-1:01) 13.1: 其他推荐的免费工具\n♎UI 设计： 可以选择 Figma (figma.com)。 文档工具： 可以选择 Notion (notion.so)。 (11:01-1:04) 13.2: 工单管理工具 ♎工单管理可以使用 GitHub 的 Project 功能。\n(11:04-11:13) 13.3: 作者开发习惯与视频总结 作者自嘲写代码风格是**\u0026ldquo;一把梭\u0026rdquo;，通常不做设计**、不写文档、也不创建 ticket。视频到此结束。\n","date":"2025-03-11T00:00:00Z","permalink":"https://yichixing.github.io/hugo-stack-dev/p/%E5%85%A8%E6%B5%81%E7%A8%8B%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%88%B0%E9%83%A8%E7%BD%B2_%E7%A9%B7%E9%AC%BC%E5%A5%97%E9%A4%90%E7%89%88/","title":"全流程项目构建到部署_穷鬼套餐版"},{"content":"part1: 独立开发者穷鬼套餐介绍 (0:00-0:06) 1.1: 论坛热门话题：独立开发者穷鬼套餐 视频开头提到，在技术论坛中经常看到一个有趣的话题，即**“独立开发者省钱之穷鬼套餐”**。\n(0:06-0:13) 1.2: 穷鬼套餐覆盖范围 这些免费工具涵盖了开发、代码托管、前后端部署、数据库以及用户行为分析等一系列功能。\n(0:13-0:17) 1.3: 适用人群 这种套餐尤其适合学生党、独立开发者以及初创公司。\n(0:17-0:24) 1.4: 零成本启动与迭代 开发者可以利用这些免费工具，零成本做出产品并发布上线，等到开始盈利以后再慢慢迭代扩容。\n(0:24-0:34) 1.5: 本期视频目标 本期视频准备用一个小项目（贪吃蛇游戏）把这些免费的工具全部串联起来，展示如何不花一分钱就能上线一个可以赚钱的业务应用。\npart2: 技术选型 (0:34-0:40) 2.1: 后端部署成本最低方案：Node.js 作者认为，对于后端，部署成本最低的方案是 Node.js。\n(0:40-0:51) 2.2: Node.js 优势：Serverless Function 原因是 ♋Node.js 可以很轻松地改造成 Serverless Function（无服务器函数）。现在很多平台提供免费的云函数部署服务，♐例如 Cloudflare Worker、Vercel 和 Netlify 等。\n(0:51-0:56) 2.3: 前端选型：影响不大 对于前端选型，作者认为其对于部署成本几乎没有影响，选择自己喜欢的就好。\n(0:56-1:04) 2.4: 前端推荐：React 与 React Native 推荐使用 React，因为后续还可以使用 React Native 改造成跨端的手机应用。\n(1:04-1:10) 2.5: ♈框架选择：Next.js ♋结合后端 Node.js 和前端 React，很自然会想到 Next.js，这是一个在海外十分流行的开发框架。\n(1:10-1:18) 2.6: Next.js 优势：SEO 友好 Next.js 具有 SEO 友好的特点，使得网站更容易被搜索引擎收录。它结合了客户端（Client）渲染和服务器端（Server）渲染（SSR/Static HTML）的能力。\n(1:18-1:24) 2.7: 本期项目选择与 AI 辅助 本期视频决定使用 Next.js 来搭建工程。由于作者对 Next.js 不太熟悉，计划将主要的开发任务交给 AI 来完成。\npart3: AI开发工具与项目初始化 (1:24-1:35) 3.1: 推荐免费AI编程方案 (VSCode + Cline + OpenRouter) 推荐一个完全免费的 AI 编程方案：在 VS Code 上使用 Cline 插件，并接入 OpenRouter 的免费 API，以达到非常好的 AI 编程效果。\n(1:35-1:44) 3.2: 安装VSCode 首先访问 code.visualstudio.com，下载并安装 VS Code。安装过程十分简单，一路点击下一步即可。\n(1:44-1:47) 3.3: VSCode 基础使用参考 作者提到之前有一个完整视频介绍 VS Code 的使用。\n(1:47-1:56) 3.4: 安装与配置Cline插件 进入 VS Code 后，在扩展市场搜索 Cline 插件，点击 Install 进行安装。\n(1:56-2:05) 3.5: 获取 OpenRouter API Key 打开 Cline 插件界面，选择 “Use your own API key”，API Provider 选择 OpenRouter，然后点击 “Get OpenRouter API Key” 按钮。\n(2:05-2:10) 3.6: OpenRouter授权 跳转到 OpenRouter 网站进行授权（该网站在国内可以直连），如果没有账号需要先注册。点击 Authorize。\n(2:10-2:23) 3.7: 完成Cline模型选择 (DeepSeek) 回到 VS Code，点击 Open 允许插件打开 URI。这样 OpenRouter API key 就配置好了。在 Model 选择处，搜索并选择免费的 DeepSeek free 模型（deepseek/deepseek-chat-v3-0324-free）。AI 编程软件配置完成。\n(2:23-2:30) 3.8: 安装Node.js ♈访问 Node.js 官网 (nodejs.org)，下载并安装 Node.js（LTS 版本）。安装过程同样是一路点击下一步。\n(2:30-2:54) 3.9: ♈ 创建Next.js项目 (Snake) ♓安装完 Node.js 后，♓重启 VS Code。打开一个新的终端（Terminal），切换到目标项目文件夹（例如 D:\\Project2025）。♋输入命令 npx create-next-app 并按回车。\n项目命名： 输入 snake（贪吃蛇）。 配置选项： 对于 TypeScript, ESLint, Tailwind CSS, src/ directory, App Router, import alias 等选项，♋全部一路回车使用默认配置。 (2:54-3:06) 3.10: 启动初始Next.js项目 项目创建成功后，使用 VS Code 打开新创建的 snake 目录，点击信任。♋在终端中输入 npm run dev 启动项目。♋浏览器访问 http://localhost:3000，可以看到一个空白的 Next.js 工程已成功运行。\n(3:07-3:18) 3.11: 使用Cline生成贪吃蛇游戏页面 接下来，准备使用AI工具（Cline）将Next.js的初始页面改造。\n目标： 将页面改造成一个贪吃蛇的网页小游戏。 操作： 在Cline中输入改造需求的prompt。（♋⌊把这个项目⌋改造成一个含吃蛇的网页版小游戏。） 结果： AI（Cline）成功生成了贪吃蛇游戏的代码，并在浏览器中演示了基本的游戏界面。 part4: 代码管理 (3:18-3:24) 4.1: 个人开发者代码管理最佳选择：GitHub 对于个人开发者来说，代码管理的最佳选择是 GitHub。\n(3:24-3:38) 4.2: GitHub 功能与优势 GitHub 是全球最大的代码仓库托管与协作平台，可以在其中存储、分享并与他人一起编写代码。它支持创建私有（private）仓库，只有自己和被授权的协作者可以访问，不用担心源代码泄露。\n(3:38-3:50) 4.3: 解决GitHub访问慢的问题 如果访问 GitHub 速度很慢，可以在搜索栏搜索“商店”，来到微软的应用商店（Microsoft Store），下载 Watt Toolkit 这个工具。\n(3:50-3:53) 4.4: GitHub 账号注册 如果没有 GitHub 账号，需要先注册一个。\n(3:53-4:07) 4.5: 安装 Git 为了将 Next.js 工程上传到 GitHub，需要先安装 Git。在 VS Code 的源代码管理（Source Control）面板，点击 “Download Git for Windows” 按钮，跳转到下载页面。下载 64 位的安装包并安装，安装过程同样是一路点击下一步。\n(4:07-4:18) 4.6: 配置 Git 并发布到 GitHub 安装完 Git 后，在 VS Code 终端中配置 Git 用户名和邮箱： git config --global user.name \u0026quot;your_username\u0026quot; git config --global user.email \u0026quot;your_email@example.com\u0026quot; 然后，在 VS Code 的源代码管理面板♋点击 “Publish Branch” 按钮。选择 “Publish to GitHub private repository”♋⌊将代码发⌋ 布为私有仓库。\n(4:18-4:23) 4.7: 确认代码备份 现在，项目代码已经提交备份到 GitHub 上面了，拥有了一个远程的 Git 仓库。\npart5: 数据库 (4:23-4:33) 5.1: 免费数据库服务推荐：Neon 与 Supabase 对于免费的数据库服务，这里推荐两个：Neon 和 Supabase。它们都提供 500 MB 的免费存储空间。本视频选择使用 Neon。\n(4:33-4:46) 5.2: 创建 Neon 数据库 来到 Neon 的官网 (neon.tech)，♋点击 “Start for free”。选择使用 GitHub 登录。\n数据库配置： Neon 是基于 PostgreSQL 的免费数据库。进入后，选择 PostgreSQL 版本（如 17），给 Project name 起个名字（如 tech-shrimp-db）。 结果： 瞬间就拥有了自己的免费数据库。 (4:46-4:50) 5.3: 查看数据库连接信息 在 Neon 的 ♈Project Dashboard，♋点击右上角的 Connect 按钮，可以查看数据库连接的相关信息（如连接字符串、用户名、密码、主机地址、数据库名）。\npart6: 数据库工具与集成 (4:50-4:57) 6.1: 数据库管理工具推荐：DBeaver 推荐使用开源免费的数据库管理工具 DBeaver。先来到其官网 (dbeaver.io)，下载 DBeaver Community 版本。\n(4:57-5:20) 6.2: ♈连接 DBeaver 到 Neon 数据库 打开 DBeaver 软件，新建数据库连接。\n选择数据库类型： 选择 PostgreSQL。 填写连接信息： 回到 Neon 的连接信息界面，将对应的主机（Host）地址、数据库（Database）名、用户（User）名、密码（Password） 复制并粘贴到 DBeaver 的相应字段中。 测试连接： 点击 “测试连接”。DBeaver 会自动下载 PostgreSQL 驱动。 结果： 连接成功。点击完成。 (5:20-5:35) 6.3: 在 DBeaver 中创建数据表 在 DBeaver 左侧导航栏可以打开数据库。♋接下来准备创建一个表，用来保存玩家分数，做一个分数排行榜。\n操作： 在 public 模式下的**表（Tables）**上右键，选择 “新建 表”。 表结构： 表名： player_score 列： 添加两列：player_name (类型 varchar) 和 score (类型 int)。 保存： 按 Ctrl+S 保存，点击执行（Persist）。 (5:35-5:58) 6.4: ♎使用 AI (Cline) 生成数据库操作代码 在 DBeaver 中右键点击刚创建的 player_score 表，选择 “生成 SQL” -\u0026gt; DDL，♐复制 CREATE TABLE 语句。\nPrompt 构建： ♐回到 VS Code 的 Cline，粘贴 CREATE TABLE 语句，并提出需求： ♐请把玩家的数据保存到 PostgreSQL 数据库里面，以下是建表语句。 ♋游戏开始前弄一个输入框，让玩家自己填名字。 (5:58-6:10) 6.5: 向 AI 提供数据库连接信息 AI（Cline） 询问 PostgreSQL 数据库的连接信息。回到 Neon 复制完整的连接字符串（Connection string）。\n(6:10-6:16) 6.6: AI 生成代码并测试 将连接字符串粘贴给 AI（Cline）。AI 修改了代码。点击 Save 保存更改。在终端运行 npm run dev 启动项目进行测试。\n(6:16-6:41) 6.7: 发现并分析错误 启动时出现构建错误：Module not found: Can't resolve 'dns'。\n定位原因： 查看 AI 写的代码，发现 page.tsx（前端页面）直接 import 并调用了 lib/db.ts 中的 saveScore 方法。而 saveScore 方法内部使用了 pg 包进行数据库连接和操作 (await pool.connect(), client.query())，并读取了环境变量 process.env.DATABASE_URL。 问题分析： Next.js 默认会将 page.tsx 作为前端组件处理。在前端（浏览器）环境中直接调用包含后端数据库操作（需要 pg 包）和敏感信息（数据库连接字符串）的代码是错误的，并且存在严重的安全隐患，会导致敏感信息暴露。 (6:41-6:56) 6.8: 向 AI 反馈错误并寻求解决方案 与 AI（Cline） 交流，指出保存数据库的逻辑似乎不正常，询问这是后端操作还是前端操作。让 AI 检查其生成的代码，特别是 db.ts 和 page.tsx。\n(6:56-7:04) 6.9: AI 提出正确解决方案 (API Route) AI（Cline） 识别到错误，并提出了正确的解决方案：\n创建 API 路由： 新建一个 API 端点（例如 /api/saveScore）。 前后端分离： 前端页面通过发送 POST 请求到这个 API 端点来触发后端的数据库保存操作。 (7:04-7:19) 7.1: 更简洁的 Next.js 解决方案 (use server) 作者指出，其实还有一种更简单的 Next.js 改法：\n在 lib/db.ts 文件的顶部加上一行 'use server'; 指令。 作用： 这会告诉 Next.js，这个文件里的函数是服务器端的 Action。Next.js 会自动处理，生成相应的 API 端点，将前后端的逻辑分割开，无需手动创建 API 路由。 (7:19-7:51) 7.2: 对 AI 编程能力的思考 这个例子体现了作者对 AI 编程的看法：\nAI 的角色： 现阶段的 AI 水平相当于一个知识面广的初级程序员。 人类的角色： 人类依旧是高级程序员、项目架构师，需要负责系统架构设计、理解编程原理（如前后端交互、安全等）。 协作方式： 不能完全依赖 AI，人类需要审查和指导 AI 的工作，将更多精力投入到架构设计和业务需求理解上。作为人类，掌握系统架构、编程原理等知识仍然是必学必会的。 part7: 部署 (7:51-8:00) 8.1: Next.js 项目最佳部署平台：Vercel 作为一个 Next.js 项目，最方便的部署方式就是部署到 Vercel 里面，因为 Vercel 目前是 Next.js 的母公司。\n(8:00-8:08) 8.2: 开始 Vercel 部署流程 来到 Vercel 官网 (vercel.com)，点击 “Start Deploying”。选择 Continue with GitHub 登录。选择之前创建的 snake GitHub 仓库，点击 Import。\n(8:08-8:18) 8.3: 配置环境变量并部署 项目设置基本保持默认。唯一需要修改的是在 Environment Variables（环境变量） 中添加数据库连接信息。\nKey: DATABASE_URL Value: 粘贴从 Neon 获取的连接字符串。 点击 Deploy 开始部署。 (8:18-8:32) 8.4: 部署完成与访问 等待大约 1 分钟左右，项目就部署完成了。点击 “Continue to Dashboard”。Vercel 会分配一个默认域名（例如 snake-bice-three.vercel.app）。\n测试： 访问该域名，功能与本地一致，可以正常游戏并保存分数到 Neon 数据库。 注意： Vercel 的默认域名只能在国外的上网环境访问到。 (8:32-8:45) 8.5: Vercel 免费额度限制 在 Vercel 的 Dashboard -\u0026gt; Usage 页面，可以看到免费用户的用量限制。作者认为 Edge Requests（每月 100 万次）可能比较瓶颈。如果升级到 Pro 模式，这些用量限制可以提高 10 倍。\npart8: 域名 (8:45-8:55) 9.1: 域名的重要性与选择 域名作为一个产品的排面，不建议用免费的，因为不稳定且非常折腾。\n(8:55-9:05) 9.2: 推荐廉价域名注册商：NameSilo 可以来到 NameSilo (namesilo.com) 这个地址，以最低成本获得一个域名。\n示例： 搜索一个6 位数字，发现 6位数字.xyz 的域名只需要 0.99 美元一年。 (9:05-9:18) 9.3: 使用 Cloudflare 托管域名 有了域名以后，可以把它托管到 Cloudflare 上面。作者提到，关于如何把域名托管到 Cloudflare，在之前的视频里有过详细介绍，这里不再赘述。\n(9:18-9:34) 9.4: Vercel 绑定自定义域名 回到 Vercel 的项目设置（Settings） -\u0026gt; Domains 页面，点击 Add。\n输入域名： 输入自己购买并托管到 Cloudflare 的域名（或子域名），例如 snake.tech-shrimp.com。 自动配置： 点击 Add 后，选择 Configure Automatically。Vercel 会自动通过 Cloudflare API 配置 DNS 记录。 (9:34-9:40) 9.5: 测试自定义域名 配置完成后，页面上会显示两个蓝色的对勾，表示配置完成。使用这个自定义域名（snake.tech-shrimp.com）同样可以访问到刚才部署的网站，并且这个域名在国内是可以直连的。\npart9: 用户行为分析 (9:40-9:51) 10.1: 免费用户行为监控工具：Microsoft Clarity 推荐使用 Microsoft Clarity (clarity.microsoft.com)，这是微软推出的免费用户行为监控工具。它提供了热点地图（Heatmaps）、用户行为录像（Session Recordings）、**报表（Dashboard）**等一系列功能。\n(9:51-10:02) 10.2: 集成 Clarity 到 Next.js 项目 登录 Clarity（可以使用 Google 账号）。在 Clarity 项目设置中，选择手动安装（Manual install），获取跟踪代码（Tracking Code）。\n操作： 回到 VS Code，打开 app/layout.tsx 文件。在 \u0026lt;body\u0026gt; 标签内，定义一个 \u0026lt;Script\u0026gt; 组件（从 next/script 导入），设置 id=\u0026quot;clarity-script\u0026quot; 和 strategy=\u0026quot;afterInteractive\u0026quot;。将 Clarity 的跟踪代码粘贴到 \u0026lt;Script\u0026gt; 组件内部。 (10:02-10:10) 10.3: 验证 Clarity 集成 保存 layout.tsx 文件。在本地重新启动项目 (npm run dev) 并进行一些操作。回到 Clarity 网站，在录制（Recordings）页面，可以看到作为用户的操作已经被录制下来了。\n(10:10-10:17) 10.4: Clarity 其他功能说明 Clarity 的仪表板（Dashboard）和热点地图（Heatmaps）需要过 24 小时才能呈现数据。至此，已将网站轻松接入了 Clarity。\npart10: 邮件 (10:17-10:39) 11.1: 免费邮件收发方案 作者之前有一期视频介绍如何使用 Cloudflare 获取无限多个免费邮箱。\n收邮件： 主要使用 **Cloudflare 的电子邮箱路由（Email Routing）**功能。 发邮件： 借助 Resend (resend.com) 的免费 API。Resend 的免费套餐每天可以发送 100 封邮件，每个月最多 3000 封。 说明： 详细用法在之前的视频里，本期不再赘述。 part11: DDoS 防御 (10:39-10:55) 12.1: 免费 DDoS 防御方案 之前也有一期完整视频介绍使用 Cloudflare 防御 DDoS 攻击。\n主要方法： 配置 CDN。 配置 IP 白名单。 使用 Cloudflare 防火墙（Firewall）。 说明： 这三种方法可以有效防御 DDoS 攻击，详细内容在那期视频里，这里不再赘述。 part12: 其他免费工具与总结 (10:55-1:01) 13.1: 其他推荐的免费工具\nUI 设计： 可以选择 Figma (figma.com)。 文档工具： 可以选择 Notion (notion.so)。 (11:01-1:04) 13.2: 工单管理工具 工单管理可以使用 GitHub 的 Project 功能。\n(11:04-11:13) 13.3: 作者开发习惯与视频总结 作者自嘲写代码风格是**“一把梭”，通常不做设计**、不写文档、也不创建 ticket。视频到此结束。\n","date":"2025-03-11T00:00:00Z","permalink":"https://yichixing.github.io/hugo-stack-dev/p/%E5%8D%87%E7%BA%A7%E7%89%88%E6%A8%A1%E6%9D%BF/","title":"升级版模板"},{"content":"","date":"2025-03-11T00:00:00Z","permalink":"https://yichixing.github.io/hugo-stack-dev/p/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF/","title":"标准模板"},{"content":"测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试\n","date":"2025-03-11T00:00:00Z","permalink":"https://yichixing.github.io/hugo-stack-dev/p/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/","title":"测试标签是否正常显示"},{"content":"[让AI解析github项目]\n《1 直接把项目克隆下来，然后用AI客户端打开即可，反正项目说明README.md是markdown，图片什么的都有，再复杂的项目AI都能用README.md解析》 \u0026lt;2 使用github MCP解析自己克隆下来的仓库\u0026gt; \u0026lt;3 给AI客户端添加URL文档集 直接把github项目地址作为文档集数据 ","date":"2025-02-20T20:14:22+08:00","permalink":"https://yichixing.github.io/hugo-stack-dev/p/ai%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90github%E9%A1%B9%E7%9B%AE/","title":"AI客户端如何解析github项目"},{"content":"[让AI解析github项目]\n\u0026lt;1 给AI客户端添加URL文档集 直接把项目文档的地址作为文档集数据》 \u0026lt;2 把在线项目文档的网页crlt+s保存下来后加入到当前项目\u0026gt; \u0026lt;3 使用联网 MCP服务 然后AI客户端联网去解析在线项目文档\u0026gt; ","date":"2025-02-20T20:14:22+08:00","permalink":"https://yichixing.github.io/hugo-stack-dev/p/ai%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B7%BB%E5%8A%A0%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/","title":"AI客户端添加项目文档"},{"content":"part1: 创建新的 GitHub 仓库 (00:04-00:23) 1.1: 推荐仓库命名 对于首次部署博客的用户，视频推荐将 GitHub 仓库名称设置为 **用户名.github.io** 的格式。视频中演示了输入 **letere-gg.github.io** 作为示例。\n(00:23-00:30) 1.2: 处理命名冲突 视频指出 **letere-gg.github.io** 这个特定名称在其账户下已被占用，因为它已被用于部署另一个项目（提及了 Hexo，但后续操作基于 Hugo）。\npart2: 理解 GitHub Pages 的 URL 结构 (00:30-00:47) 2.1: 用户名.github.io 仓库的 URL 视频展示了名为 **letere-gg.github.io** 的仓库，在其 Settings -\u0026gt; Pages 中，生成的 GitHub Pages 网站 URL 是根域名 **https://letere-gg.github.io**。\n(00:48-01:02) 2.2: 普通仓库的 URL 视频接着展示了另一个名为 **hugo-stack** 的仓库，在其 Settings -\u0026gt; Pages 中，生成的 GitHub Pages 网站 URL 带有仓库名称作为子路径，即 **https://letere-gg.github.io/hugo-stack**。\n(01:02-01:18) 2.3: 部署建议 基于以上对比，视频建议首次部署时使用 用户名.github.io 格式命名仓库，这样生成的网站 URL 不带子路径，可以避免一些潜在的 bug。\npart3: 设置新仓库与本地项目配置 (01:21-01:35) 3.1: 创建示例仓库 由于推荐的仓库名已被占用，视频演示创建了一个新的示例仓库，命名为 **hugo-dev**，并确保其设置为 Public（公开），因为只有公开仓库才能部署 GitHub Pages 静态页面。\n(01:35-01:46) 3.2: 准备上传代码 仓库创建成功后，页面显示了用于上传代码的 Git 命令。视频提到下一步是上传代码，但在此之前需要修改一个配置文件。\n(01:46-02:16) 3.3: 修改 hugo.yaml 文件 视频打开本地项目中的 **hugo.yaml** 文件，指出需要修改 **baseURL** 配置项。将其值修改为与 GitHub Pages 部署后期望的 URL 一致。因为仓库名是 hugo-dev，所以 baseURL 被设置为 **https://letere-gg.github.io/hugo-dev/**，必须包含末尾的仓库名子路径。\npart4: 生成静态网站并上传至 GitHub (02:18-02:46) 4.1: 使用 Hugo 生成站点 视频演示在本地项目文件夹中♈删除旧的 public 文件夹（如果存在）。然后在项目根目录打开命令提示符 (cmd)，♈运行 **hugo -D** 命令。此命令使用 Hugo 编译项目，并♈将生成的静态网站文件输出到 public 文件夹中。\n(02:46-03:18) 4.2: 初始化 Git 仓库 ♈进入新生成的 public 文件夹，确认里面是静态网站内容。在此 public 文件夹内打开命令提示符 (cmd)，并♈执行 **git init** 命令，将其初始化为一个 Git 仓库。\n(03:18-03:49) 4.3: 添加文件、提交并关联远程仓库 ♈按照 GitHub 页面提供的指南（略作修改）：\n使用 **git add .** 命令将 public 文件夹内所有生成的静态文件添加到暂存区（视频强调是 . 而不是 README.md）。 使用 **git commit -m \u0026quot;first commit\u0026quot;** 提交更改。 使用 **git branch -M main** 将当前分支重命名为 main。 使用 **git remote add origin https://github.com/letere-gg/hugo-dev.git** 关联到之前创建的远程 GitHub 仓库。 (03:49-04:08) 4.4: 推送代码到 GitHub ♈执行 **git push -u origin main** 命令，将本地 main 分支的代码推送到 GitHub 远程仓库。视频提到在国内环境可能需要开启代理才能成功推送。推送完成后，刷新 GitHub 仓库页面，可以看到静态文件已成功上传。\npart5: 启用 GitHub Pages 并验证部署 (04:09-04:23) 5.1: 配置 Pages 源 返回 GitHub 上的 hugo-dev 仓库页面，进入 Settings -\u0026gt; Pages 选项卡。在 \u0026ldquo;Build and deployment\u0026rdquo; 部分下的 \u0026ldquo;Source\u0026rdquo; 设置中，选择 Deploy from a branch，然后从 \u0026ldquo;Branch\u0026rdquo; 下拉菜单中选择 **main** 分支，点击 Save。\n(04:23-05:24) 5.2: 等待部署完成 保存设置后，GitHub Pages 开始部署过程。视频指出这需要一些时间。等待页面刷新，直到显示 \u0026ldquo;Your site is live at \u0026hellip;\u0026rdquo; 并给出最终的网站 URL：**https://letere-gg.github.io/hugo-dev/**。\n(05:24-05:35) 5.3: 访问并验证站点 点击页面上提供的网站链接。浏览器成功加载了部署好的博客网站，显示内容正常，证明部署已成功。视频总结这个过程很简单。\n","date":"2025-02-20T20:14:22+08:00","permalink":"https://yichixing.github.io/hugo-stack-dev/p/github-page%E9%83%A8%E7%BD%B2hugo%E5%8D%9A%E5%AE%A2/","title":"github page部署hugo博客"},{"content":"Hugo博客的action代码：解析用aciton配置hugo博客的action代码 好的，这是视频中展示的、由社区贡献者 (peaceiris) 维护的用于通过 GitHub Actions 部署 Hugo 站点的 Actions 工作流 YAML 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 # 工作流名称 name: deploy # 触发工作流的事件 on: push: branches: # 仅在 main 分支被推送时触发 - main # 定义工作流中的作业 jobs: # 定义一个名为 deploy 的作业 deploy: # 指定作业运行的环境为最新的 Ubuntu 系统 runs-on: ubuntu-latest # 定义作业中的步骤 steps: # 步骤1：检出代码 - name: Checkout # 使用官方的 actions/checkout 动作来获取仓库代码 uses: actions/checkout@v4 with: # 获取完整的 Git 历史记录（对于部署工具 peaceiris/actions-gh-pages 可能需要） # 0 表示获取所有历史，而不是默认的浅克隆（只获取最后一次提交） fetch-depth: 0 # 步骤2：设置 Hugo 环境 - name: Setup Hugo # 使用社区维护的 peaceiris/actions-hugo 动作来安装 Hugo uses: peaceiris/actions-hugo@v3 with: # 指定要安装的 Hugo 版本为最新版 hugo-version: \u0026#39;latest\u0026#39; # 明确指定安装 Hugo 的 Extended 版本（支持 SASS/SCSS 等特性） extended: true # 步骤3：构建网站 - name: Build Web # 运行 Hugo 命令来生成静态网站文件 # -D 参数表示包含草稿内容（如果本地预览用过，这里保持一致，或按需移除） run: hugo -D # 步骤4：部署网站到 GitHub Pages - name: Deploy Web # 使用社区维护的 peaceiris/actions-gh-pages 动作来部署 uses: peaceiris/actions-gh-pages@v4 with: # 指定用于认证的 Personal Access Token (PAT) # ${{ secrets.TOKEN }} 会从仓库的 Secrets 中读取名为 TOKEN 的值 # （视频中占位符是 你的token变量名，这里假设你设置为 TOKEN） PERSONAL_TOKEN: ${{ secrets.TOKEN }} # 指定要将静态文件部署到的目标仓库 # 格式为：你的GitHub用户名/目标仓库名 # （视频中占位符是 你的github名/你的仓库名，这里假设目标仓库是 letere-gz/hugo-dev） EXTERNAL_REPOSITORY: letere-gz/hugo-dev # 指定将静态文件推送到目标仓库的哪个分支（通常是 gh-pages 或 main） PUBLISH_BRANCH: main # 指定包含构建好的静态网站文件的目录（Hugo 默认生成到 public） PUBLISH_DIR: ./public # 自定义部署时 Git 提交的信息 commit_message: auto deploy 代码解释 (遵循托勒斯法则/Law of Demeter - 关注“做什么”而非“怎么做”的内部细节):\nname: deploy\n作用: 给这个自动化流程（工作流）起个名字，叫做 deploy。这个名字会显示在 GitHub 仓库的 \u0026ldquo;Actions\u0026rdquo; 标签页里，方便你识别。 托勒斯法则: 你只需要知道这是流程的名字，不需要关心 GitHub 内部如何使用这个名字。 on: push: branches: [main]\n作用: 定义触发这个自动化流程的条件。这里设置的是：当你向 main 这个分支推送 (push) 代码时，这个流程就会自动开始运行。 托勒斯法则: 你只需要知道“推送到 main 分支”这个动作会启动流程，不需要关心 GitHub 是如何监控推送事件或分支的。 jobs: deploy:\n作用: 定义这个流程中要执行的一个或多个任务组（作业）。这里只有一个任务组，名字叫 deploy。 托勒斯法则: 你只需要知道这里开始定义一个主要的工作单元，它包含了一系列要完成的步骤。 runs-on: ubuntu-latest\n作用: 指定 deploy 这个任务组运行在什么样的虚拟环境里。这里指定的是 ubuntu-latest，意味着 GitHub 会提供一个最新的 Ubuntu Linux 虚拟服务器来运行后续步骤。 托勒斯法则: 你只需要知道你的自动化步骤将在一个 Linux 环境中执行，不需要关心这个环境是如何创建和管理的。 steps:\n作用: 定义 deploy 作业中要按顺序执行的具体步骤。 - name: Checkout\n作用: 给这个步骤起个名字，叫 Checkout，方便在日志中查看。 ♈uses: actions/checkout@v4: 使用一个预先写好的、官方提供的“动作” (Action)，叫做 actions/checkout (版本是 v4)。♐这个动作的功能是**把你的仓库代码下载（检出）**到当前的虚拟运行环境中，以便后续步骤可以使用这些代码。 with: fetch-depth: 0: 这是给 actions/checkout 动作传递的一个参数。fetch-depth: 0 的意思是下载完整的代码历史记录，而不是默认只下载最近的一次提交。部署动作 peaceiris/actions-gh-pages 有时需要完整的历史记录才能正确工作。 托勒斯法则: 你只需要知道这个步骤会把你的代码准备好，并且需要完整的历史。你不需要知道 checkout 动作内部是如何通过 Git 命令实现下载的。 - name: Setup Hugo\n作用: 步骤名，设置 Hugo 环境。 ♈uses: peaceiris/actions-hugo@v3: 使用一个由社区开发者 (peaceiris) 维护的 Action，叫做 actions-hugo (版本是 v3)。这个动作专门用来安装和配置 Hugo。 【♓这一步的作用是把能够执行 hugo 命令的那个程序安装好 ，因为♐即使你的项目文件上传到了仓库，也仍然需要安装 Hugo 包。你上传到仓库的是你博客的“原材料”（Markdown 文件、主题、配置），而不是制作网站的“工具”（即 Hugo 程序本身））。” 托勒斯法则: 你只需要知道，这一步负责获取你的博客源代码（包括你的 Markdown 文章、主题、配置文件等），并将它们准备好，以便后续步骤使用。它确实使用了你推送到仓库的文件，♈Action 运行环境是一个临时的、干净的 Linux 系统，它默认并没有安装 Hugo 这个“工具”】 with:: 给 actions-hugo 动作传递参数： hugo-version: 'latest': 告诉动作要安装最新版本的 Hugo。 extended: true: 告诉动作要安装 Hugo 的 Extended（扩展）版本。这个版本支持 SASS/SCSS 等高级功能，很多主题需要它。 托勒斯法则: 你只需要知道这个步骤会自动安装好你需要的 Hugo 版本，不需要关心它具体从哪里下载、如何安装。 - name: Build Web\n作用: 步骤名，构建网站。 run: hugo -D: 直接运行一条命令：hugo -D。这就是你在本地用来生成静态网站文件的命令。它会读取你的 Hugo 项目文件，并把最终的网站文件（HTML, CSS, JS, 图片等）生成到默认的 public 目录下。-D 参数是包含标记为草稿 (draft) 的内容。 托勒斯法则: 你只需要知道这个步骤执行了 Hugo 的构建命令，并产出了 public 文件夹，就像你在本地操作一样。 - name: Deploy Web\n作用: 步骤名，部署网站。 uses: peaceiris/actions-gh-pages@v4: 使用另一个由 peaceiris 维护的 Action，叫做 actions-gh-pages (版本是 v4)。这个动作专门用来将一个文件夹的内容推送到指定仓库的指定分支，非常适合部署到 GitHub Pages。 with:: 给 actions-gh-pages 动作传递部署所需的参数： PERSONAL_TOKEN: ${{ secrets.TOKEN }}: 提供认证凭证。这个动作需要权限去推送代码到目标仓库。这里使用的是你之前创建并存储在仓库 Secrets 中的 Personal Access Token (PAT)。secrets.TOKEN 表示去读取名为 TOKEN 的那个 Secret 的值。 EXTERNAL_REPOSITORY: letere-gz/hugo-dev: 指定目标仓库。告诉动作要把 public 目录下的文件推送到 letere-gz 这个用户（或组织）下的 hugo-dev 仓库。你需要将 letere-gz/hugo-dev 替换成你自己的 GitHub 用户名和用于托管 GitHub Pages 的仓库名 (例如 your-username/your-username.github.io)。 PUBLISH_BRANCH: main: 指定目标分支。告诉动作要把文件推送到目标仓库的 main 分支。你需要根据你的 GitHub Pages 设置，将其修改为正确的目标分支 (常见的有 gh-pages 或 main)。 PUBLISH_DIR: ./public: 指定要部署的内容来源。告诉动作需要推送的是当前目录下 public 文件夹里的所有内容。 commit_message: auto deploy: 设置部署时产生的 Git 提交信息。每次部署都是一次 Git 提交，这里设置提交信息为 \u0026ldquo;auto deploy\u0026rdquo;。 托勒斯法则: 你只需要知道这个步骤负责把 public 目录的内容，使用你提供的 Token 认证后，推送到你指定的目标仓库和分支。你不需要关心它内部是如何进行 Git 操作和推送的。 Author:\nURL: http://example.org/posts/hugo%E5%8D%9A%E5%AE%A2/action-%E4%BB%A3%E7%A0%81%E6%88%91%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%8D%E6%9D%A5%E7%9A%84%E4%B8%8D%E7%94%A8ai%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81steps%E5%AD%97%E6%AE%B5%E4%B8%8B%E7%9A%84users%E5%8F%82%E6%95%B0/\n","date":"2025-02-20T20:14:22+08:00","permalink":"https://yichixing.github.io/hugo-stack-dev/p/hugo%E5%8D%9A%E5%AE%A2action%E4%BB%A3%E7%A0%81%E9%83%A8%E7%BD%B2action%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/","title":"hugo博客action代码部署：action代码解析"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 # 工作流名称 name: deploy # 触发工作流的事件 on: push: branches: # 仅在 main 分支被推送时触发 - main # 定义工作流中的作业 jobs: # 定义一个名为 deploy 的作业 deploy: # 指定作业运行的环境为最新的 Ubuntu 系统 runs-on: ubuntu-latest # 定义作业中的步骤 steps: # 步骤1：检出代码 - name: Checkout # 使用官方的 actions/checkout 动作来获取仓库代码 uses: actions/checkout@v4 with: # 获取完整的 Git 历史记录（对于部署工具 peaceiris/actions-gh-pages 可能需要） # 0 表示获取所有历史，而不是默认的浅克隆（只获取最后一次提交） fetch-depth: 0 # 步骤2：设置 Hugo 环境 - name: Setup Hugo # 使用社区维护的 peaceiris/actions-hugo 动作来安装 Hugo uses: peaceiris/actions-hugo@v3 with: # 指定要安装的 Hugo 版本为最新版 hugo-version: \u0026#39;latest\u0026#39; # 明确指定安装 Hugo 的 Extended 版本（支持 SASS/SCSS 等特性） extended: true # 步骤3：构建网站 - name: Build Web # 运行 Hugo 命令来生成静态网站文件 # -D 参数表示包含草稿内容（如果本地预览用过，这里保持一致，或按需移除） run: hugo -D # 步骤4：部署网站到 GitHub Pages - name: Deploy Web # 使用社区维护的 peaceiris/actions-gh-pages 动作来部署 uses: peaceiris/actions-gh-pages@v4 with: # 指定用于认证的 Personal Access Token (PAT) # ${{ secrets.TOKEN }} 会从仓库的 Secrets 中读取名为 TOKEN 的值 # （视频中占位符是 你的token变量名，这里假设你设置为 TOKEN） PERSONAL_TOKEN: ${{ secrets.TOKEN }} # 指定要将静态文件部署到的目标仓库 # 格式为：你的GitHub用户名/目标仓库名 # （视频中占位符是 你的github名/你的仓库名，这里假设目标仓库是 letere-gz/hugo-dev） EXTERNAL_REPOSITORY: letere-gz/hugo-dev # 指定将静态文件推送到目标仓库的哪个分支（通常是 gh-pages 或 main） PUBLISH_BRANCH: main # 指定包含构建好的静态网站文件的目录（Hugo 默认生成到 public） PUBLISH_DIR: ./public # 自定义部署时 Git 提交的信息 commit_message: auto deploy ","date":"2025-02-20T20:14:22+08:00","permalink":"https://yichixing.github.io/hugo-stack-dev/p/hugo%E5%8D%9A%E5%AE%A2action%E4%BB%A3%E7%A0%81%E9%83%A8%E7%BD%B2hugo%E5%8D%9A%E5%AE%A2%E7%9A%84action%E4%BB%A3%E7%A0%81%E6%9C%AC%E4%BD%93/","title":"hugo博客action代码部署：hugo博客的action代码本体"},{"content":"part1: 介绍 GitHub Action 自动化部署 Hugo 博客 (00:00-00:09) 1.1: 介绍目标\n视频开篇展示了一个本地运行的 Hugo 博客 (localhost:1313)。 目标是向大家介绍如何通过 GitHub 的 GitHub Actions 功能来自动部署博客。 (00:09-00:32) 1.2: 手动部署痛点与自动化优势\n♈指出传统方式下，每次修改完文件后，都需要手动将生成的 public 文件夹上传到服务器或托管平台，这个过程比较麻烦。 ♈使用 GitHub Actions 可以实现自动化：自动帮我们生成 public 目录，并将其部署到静态页面网站（如 GitHub Pages）。 ♈优点：只需提交代码 (git push)，后续的构建和部署过程就能自动完成，方便很多。 part2: 创建 GitHub 仓库并推送 Hugo 源码 (00:32-00:41) 2.1: 创建仓库准备\n要实现自动化部署，首先需要一个 GitHub 仓库来存放 Hugo 项目的主文件（源代码）。 操作：导航到 GitHub 网站，准备创建一个新的仓库。 (00:41-01:12) 2.2: 创建私有仓库\n在 GitHub 创建新仓库页面（经历短暂的网络卡顿后），设置仓库信息： 仓库名：hugo-main 可见性：建议选择私有（Private），因为源代码一般不需要公开。 操作：点击 Create repository 完成创建。 (01:12-01:24) 2.3: 上传文件准备\n仓库创建完成后，需要将本地的 Hugo 项目文件上传到这个新仓库。 关键点：上传前需要注意忽略掉一些不需要版本控制的文件。 (01:24-02:04) 2.4: 配置 .gitignore 忽略生成文件\n说明：Hugo 项目中的某些文件/目录是自动生成的，不应该提交到源代码仓库，包括： public/：Hugo 生成的静态网站文件目录。 resources/：Hugo 处理后的资源缓存目录。 hugo.build.lock：构建锁文件。 hugo.exe：（如果在 Windows 下）Hugo 可执行文件本身。 ♈ 操作：在本地 Hugo 项目根目录下，创建一个名为 .gitignore 的文件。 ♈操作：编辑 .gitignore 文件，将上述需要忽略的文件名或目录名（如 public, resources, hugo.build.lock, hugo.exe）添加进去，每行一个。 ♈目的：保证上传到 GitHub 的是最干净、最原始的 Hugo 项目文件。 (02:04-03:10) 2.5: Git 推送操作\n操作：在本地 Hugo 项目目录下打开命令行终端 (cmd)。 ♈操作：执行一系列 **Git 命令（仓库首页有）**来初始化仓库、添加文件并推送到远程 GitHub 仓库： git init：初始化本地 Git 仓库。 git add .：添加所有文件到暂存区（.gitignore 会生效，忽略指定文件）。 git commit -m \u0026quot;first commit\u0026quot;：提交更改。 git branch -M main：重命名当前分支为 main。 git remote add origin https://github.com/letere-gz/hugo-main.git：关联远程仓库地址。 git push -u origin main：推送本地 main 分支到远程仓库。 验证：切换到 GitHub 仓库页面刷新，确认项目文件已上传，且 .gitignore 中指定的文件（如 public）未被上传。 part3: 配置 GitHub Actions Workflow (03:10-03:59) 3.1: 参考官方与民间方案\n提及：作者自己的博客 (letere-gz.github.io/hugo-stack/) 提供了关于 Hugo + GitHub 免费部署的教程文章。 ♈参考：查看 Hugo 官方文档 (gohugo.io) 中关于 Hosting and deployment -\u0026gt; Host on GitHub Pages 的部分。 发现：官方文档提供了一个使用 GitHub Actions 部署的 workflow 示例（Step 6 中的 hugo.yml 文件内容）。 评价：作者认为官方提供的 workflow 文件内容很长，配置起来可能有点麻烦。 (03:59-04:13) 3.2: 引入简化版 Workflow\n建议：作者推荐使用一个民间大佬（peaceiris）编写和维护的简化版的 GitHub Actions workflow 配置。 来源：该简化配置可以在作者的教程文章中找到（或者直接参考 peaceiris/actions-hugo 和 peaceiris/actions-gh-pages 这两个 Action）。 优势：相比官方示例，这个版本更简洁、更方便使用。 (04:13-06:15) 3.3: 解析简化版 Workflow 配置\n展示：作者展示了其教程文章中的简化版 workflow YAML 文件内容，并逐段解释其含义： name: deploy: 定义 Workflow 的名称，显示在 Actions 列表里。 on: push: branches: [ main ]: 设置触发条件，当代码被 push 到 main 分支时，自动执行此 workflow。 jobs: deploy:: 定义一个名为 deploy 的作业 (job)。 ♈ runs-on: ubuntu-latest: 指定该作业运行在 GitHub 提供的最新版 Ubuntu 虚拟环境上。 steps:: 定义该作业包含的一系列步骤 (step)。 - name: Checkout: 步骤名称。 uses: actions/checkout@v4: 使用官方提供的 checkout Action，将仓库代码下载到运行环境中。 with: fetch-depth: 0: 获取完整的 Git 历史记录（对于 Hugo 可能需要）。 - name: Setup Hugo: 步骤名称。 uses: peaceiris/actions-hugo@v3: 使用 peaceiris 提供的 actions-hugo Action 来安装和设置 Hugo 环境。 with: hugo-version: 'latest', extended: true: 配置 actions-hugo，指定安装最新 (latest) 版本的 Hugo，并且是扩展 (extended) 版本（支持 Sass/SCSS）。 - name: Build Web: 步骤名称。 run: hugo -D: 执行 Hugo 命令 (hugo 默认会构建，-D 表示包含草稿内容，但在部署时通常不需要 -D，作者这里可能写错了，通常只用 hugo)，生成静态网站文件到 public 目录。 - name: Deploy Web: 步骤名称。 ♈ uses: peaceiris/actions-gh-pages@v4: 使用 peaceiris 提供的 actions-gh-pages Action，将构建好的网站部署到 GitHub Pages。 with:: 配置 actions-gh-pages。 PERSONAL_TOKEN: ${{ secrets.你的token变量名 }}: 关键配置，用于授权 Action 推送代码到目标仓库。需要一个个人访问令牌 (PAT)，并将其存储为仓库的 Secret。你的token变量名 需要替换成实际设置的 Secret 名称。 EXTERNAL_REPOSITORY: 你的github名/你的仓库名: 关键配置，指定目标仓库，即用来托管 GitHub Pages 的仓库地址（例如 letere-gz/hugo-dev），必须修改为用户自己的 Pages 仓库。 PUBLISH_BRANCH: main: 指定将 public 目录的内容推送到目标仓库的哪个分支（通常是 gh-pages 或 main，取决于 Pages 设置）。 PUBLISH_DIR: ./public: 指定要发布的目录，即 Hugo 构建生成的 public 目录。 commit_message: auto deploy: 自动部署时 Git 提交的消息。 part4: 创建和配置 Personal Access Token (PAT) (06:15-06:49) 4.1: Token 的作用与必要性\n重申：Workflow 中的 PERSONAL_TOKEN 参数需要填入一个个人访问令牌 (PAT)。 目的：这个 Token 用于身份验证，使得 GitHub Actions 有权限将构建好的静态文件推送到目标 GitHub Pages 仓库。没有它，推送会因权限不足而失败。 操作准备：接下来演示如何生成这个 Token。 (06:49-08:09) 4.2: 生成 Personal Access Token (Classic)\n操作路径：在 GitHub 页面，点击右上角个人头像 -\u0026gt; Settings -\u0026gt; 左侧菜单滚动到底部找到 Developer settings -\u0026gt; Personal access tokens -\u0026gt; Tokens (classic)。 操作：点击 Generate new token 按钮，选择 Generate new token (classic)。 配置 Token： Note：给 Token 起一个描述性名称，例如 “用作部署”。 Expiration：设置过期时间。作者建议选择 No expiration（永不过期），理由是避免定期更新 Token 的麻烦。但也提示 GitHub 出于安全考虑建议设置过期时间。对于个人私有仓库，作者认为永不过期问题不大。 ♈* Select scopes：选择 Token 的权限范围。必须勾选以下两项： repo：授予对仓库的完全控制权（包括推送）。 workflow：授予更新 GitHub Actions workflow 的权限。 生成：点击页面底部的 Generate token 按钮。 (08:09-08:41) 4.3: 保存 Token\n♈ 重要提示：Token 生成后，完整的 Token 字符串只会显示这一次。必须立即复制 (Copy 按钮) 并将其保存在安全的地方（例如，作者将其粘贴到了本地的记事本文件中）。如果关闭或刷新页面，将无法再次查看完整的 Token。 (08:41-10:19) 4.4: 配置 Repository Secret\n♈ 目的：将生成的 Token 安全地提供给 GitHub Actions workflow 使用。不应该直接将 Token 字符串写入 YAML 文件。 操作路径：回到存放 Hugo 源代码的仓库（即 hugo-main），进入该仓库的 Settings -\u0026gt; 左侧菜单 Security 下的 Secrets and variables -\u0026gt; Actions。 ♈操作：点击 New repository secret 按钮。 配置 Secret： Name：输入 Secret 的名称。这个名称必须与 workflow YAML 文件中 secrets. 后面引用的名称完全一致。作者在这里将其命名为 TOKEN。 Secret：将刚才复制并保存的完整 Token 字符串粘贴到这里。 保存：点击 Add secret。 ♈优点：使用 Secrets 可以隐藏敏感信息，workflow 运行时会安全地注入该值，比硬编码在代码中安全得多。 part5: 演示自动化部署流程 (10:19-10:31) 5.1: 准备 workflow 文件\n操作：回到本地的 Hugo 项目目录（dev 目录）。 下一步：需要将包含 workflow 配置的 YAML 文件添加到项目中。 (10:31-11:29) 5.2: 创建并编辑 workflow 文件\n♈操作：在本地 Hugo 项目根目录下，创建 .github 文件夹，然后在 .github 文件夹内创建 workflows 文件夹。 ♈操作：在 workflows 文件夹中，新建一个 YAML 文件，作者将其命名为 hugo_deploy.yaml。 ♈操作：使用文本编辑器打开 hugo_deploy.yaml 文件，将之前从教程文章中复制的简化版 workflow 内容粘贴进去。 (11:29-11:57) 5.3: 修改 workflow 文件参数\n操作：在粘贴好的 workflow 内容中，修改两个关键的 with 参数： ♈将 PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} 修改为 PERSONAL_TOKEN: ${{ secrets.TOKEN }}，确保 TOKEN 与上一步创建的 Repository Secret 名称一致。 ♈ 将 EXTERNAL_REPOSITORY: 你的github名/你的仓库名 修改为实际的 GitHub Pages 目标仓库地址，作者修改为 letere-gz/hugo-dev。 保存：保存对 hugo_deploy.yaml 文件的修改。 (11:57-12:47) 5.4: 创建新文章验证部署\n目的：为了验证推送到 main 分支是否能自动触发部署，需要对项目做一些更改，例如添加一篇新文章。 现状：先查看本地 (localhost:1313) 运行的博客，确认当前的文章列表（只有一个 \u0026ldquo;Chinese Test\u0026rdquo;）。 (12:47-13:22) 5.5: 本地新增文章\n操作：在命令行中，执行 hugo new content post/newnewnew/index.md 命令，在 content/post 目录下创建一个名为 newnewnew 的子目录，并在其中生成 index.md 文件。 操作：再次执行 hugo server -D 启动本地服务。 验证：访问 localhost:1313，确认名为 Newnewnew 的新文章已成功创建并显示在本地博客首页。 (13:22-14:03) 5.6: 推送更改触发 Action\n操作：在命令行中按 Ctrl+C 停止本地 hugo server。 操作：执行 Git 命令将更改推送到远程仓库： ♈* git add .：添加所有更改（包括新文章 .md 文件和 .github/workflows/hugo_deploy.yaml 文件）。 ♈* git commit -m \u0026quot;update\u0026quot;：提交更改，提交信息为 \u0026ldquo;update\u0026rdquo;。 ♈* git push：推送本地 main 分支的提交到 GitHub 上的 hugo-main 仓库。 part6: 验证自动化部署结果与总结 (14:03-14:29) 6.1: 观察 Action 执行\n操作：切换回 GitHub 网站，进入 hugo-main 仓库的 Actions 标签页。 观察：可以看到一个由刚才的 push 事件触发的名为 update（commit 信息）的 workflow run 正在执行（黄色图标，in progress）或者已经执行完毕（绿色勾，Success）。 检查：点击该 workflow run，可以查看名为 deploy 的 job，再点击进去可以看到详细的执行步骤和日志，确认 Checkout, Setup Hugo, Build Web, Deploy Web 等步骤均已成功完成。 (14:29-14:53) 6.2: 验证部署结果（首次刷新）\n操作：打开或刷新用于 GitHub Pages 托管的目标网站（作者的是 https://letere-gz.github.io/hugo-dev/）。 发现：第一次刷新时，页面上可能仍然没有显示新添加的文章 Newnewnew。 原因：GitHub Pages 的部署和 CDN 的缓存更新通常会有一定的延迟。 (14:53-15:10) 6.3: 验证部署结果（成功显示）\n操作：再次刷新 GitHub Pages 网站页面。 结果：新添加的文章 Newnewnew 成功出现在了部署后的网站首页上。 结论：这表明 GitHub Actions 已经成功地自动拉取了 hugo-main 仓库的最新代码，使用 Hugo 进行了构建，并将生成的 public 目录内容推送并部署到了 hugo-dev 这个 GitHub Pages 仓库。 (15:10-15:40) 6.4: 总结与结束\n总结：通过以上设置，现在实现了自动化部署流程。开发者只需专注于编写文章 (.md 文件)，完成后执行 git push 将代码推送到源仓库 (hugo-main)。GitHub Actions 就会自动接管后续的构建和部署工作，无需再手动处理 public 目录的生成和上传。 评价：整个过程变得非常方便和省心。 ","date":"2025-02-20T20:14:22+08:00","permalink":"https://yichixing.github.io/hugo-stack-dev/p/%E4%BD%BF%E7%94%A8github-action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E5%8D%9A%E5%AE%A2%E5%88%B0page%E4%BB%93%E5%BA%93/","title":"使用github-action自动部署hugo博客到“page”仓库"},{"content":"part1: Hugo + GitHub 免费部署自己的博客介绍 (00:00-00:15) 1.1: 视频目标与演示 视频旨在分享如何使用 Hugo 和 GitHub 免费部署一个属于自己的个人博客。开头展示了作者已经部署成功的博客页面作为最终效果预览。\n(00:15-00:37) 1.2: 作者说明与目的 作者声明自己并非专业的教学视频制作者，制作此视频主要是因为近期想更新内容，且正好在研究 Hugo 博客的搭建过程。目的是分享经验，帮助观看者在搭建过程中少走弯路。\n(00:37-00:44) 1.3: 博客内容示例 简要展示了博客中的一篇文章，内容即为本次视频所要讲解的 Hugo + GitHub 免费部署博客的教程记录。\npart2: 搭建动机与 Hugo vs Hexo 对比 (00:45-00:57) 2.1: 历史背景 (Hexo) 作者提到自己之前已经使用 Hexo 框架搭建过一个个人博客 (展示了之前的 Hexo 博客页面)。\n(00:57-01:19) 2.2: 转向 Hugo 的原因 解释了为何选择使用 Hugo 重新搭建：更换了新电脑 (天选4) 后，之前的 Hexo 本地文件丢失（因为没有上传备份到 GitHub），所以需要重新搭建。借此机会研究并尝试了 Hugo。\n(01:19-01:30) 2.3: Hugo 使用体验 作者认为实际使用下来，Hugo 感觉比 Hexo 更方便。\n(01:30-01:41) 2.4: 对新手的建议 (Hugo vs Hexo) 指出 Hugo 的官方文档基本都是英文，可能对新手不太友好。因此，推荐新手优先尝试 Hexo (文档相对更完善，中文资源多)。使用 Hugo 需要啃英文文档，对新手来说较为麻烦。\npart3: 下载 Hugo (01:41-01:54) 3.1: 开始教程：下载准备 正式进入教程环节，第一步是下载 Hugo。作者打开浏览器并搜索 Hugo。\n(01:54-02:22) 3.2: 定位 Hugo GitHub Releases 进入 Hugo 官网 (gohugo.io)，点击 GitHub 链接跳转到 Hugo 的 GitHub 仓库。在仓库页面，点击 Tags (标签/版本) 来查找发布版本。选择了当时的最新版本 v0.131.0。\n(02:22-02:30) 3.3: 选择并下载 Hugo Extended 版本 在版本发布页面向下滚动到 Assets (资源) 部分，强调需要下载 Extended (扩展) 版本，并选择了适用于 Windows 64位的 hugo_extended_0.131.0_windows-amd64.zip 文件进行下载。\npart4: Hugo 文件准备与站点创建 (02:30-02:55) 4.1: 解压 Hugo 文件 展示了下载好的 zip 压缩包。在桌面上创建了一个名为 test 的新文件夹。将下载的 zip 包移动到 test 文件夹中，并进行解压。解压后得到包含 hugo.exe 等文件的文件夹。\n(02:55-03:04) 4.2: Hugo 可执行文件说明 强调 Hugo 是用 Go 语言编写的，但使用时不需要单独安装 Go 环境，♈下载解压后的 hugo.exe 可执行文件即可直接使用，这一点很方便。清理了多余的文件和文件夹，只保留核心文件。\n(03:04-03:13) 4.3: 打开命令行工具 (CMD) 在包含 hugo.exe 的文件夹（路径类似 C:\\Users\\Letere\\Desktop\\test\\hugo_extended_0.131.0_windows-amd64）的地址栏输入 cmd 并回车，从而直接在该目录下打开命令行窗口。\n(03:13-03:34) 4.4: 创建新站点命令 (hugo new site) 在命令行窗口中，♈输入命令 hugo new site dev。该命令会创建一个名为 dev 的新文件夹，并在其中♈♈生成 Hugo 站点的基本目录结构。\n(03:34-03:45) 4.5: 理解命令输出与后续步骤 展示了 hugo new site 命令执行后的输出提示，其中包含了建议的后续操作步骤，如切换目录、安装主题、编辑配置、创建内容和启动服务。作者截图保存了这些步骤提示。\n(03:45-04:10) 4.6: 切换目录与复制 Hugo 执行文件 根据提示，首先使用 cd dev 命令切换到新创建的 dev 站点根目录。因为 hugo.exe 不在系统路径中，需要将其复制到当前的 dev 目录下，才能在该目录中执行 Hugo 相关命令。\npart5: 本地预览 (无主题) (04:10-04:28) 5.1: 准备本地预览 根据之前的步骤提示，下一步是安装主题，但作者决定先不安装主题，直接启动本地服务看下效果。\n(04:28-05:08) 5.2: 启动 Hugo 本地服务 (hugo server -D) 在 dev 目录下，执行命令 hugo server -D 来启动 Hugo 的内置Web服务器进行本地预览。解释 -D 是 --buildDrafts 的简写，用于包含草稿内容。命令成功执行后，输出了本地服务器地址 http://localhost:1313。\n(05:08-05:16) 5.3: 浏览器访问与结果 (Page Not Found) 复制该地址并在浏览器中打开。♈页面显示 Page Not Found (404错误)。作者解释这是正常现象，因为目前既没有安装主题，也没有任何内容，但这表明 Hugo 服务已经成功启动。\npart6: 查找与下载 Hugo 主题 (Stack) (05:16-05:33) 6.1: 前往 Hugo 主题站 回到命令行输出提示，明确需要安装一个主题。再次访问 Hugo 官网 (gohugo.io)，点击导航栏中的 Themes。\n(05:33-05:56) 6.2: 选择 Stack 主题 浏览 Hugo 主题列表，作者选择了名为 Stack 的主题（卡片式风格，适用于博主）。点击进入该主题的详情页。\n(05:56-06:13) 6.3: ♈下载 Stack 主题源码 在 Stack 主题详情页，点击 Download 按钮，跳转到该主题的 GitHub 仓库 (CallMeMaybe/hugo-theme-stack)。在仓库页面，同样通过 Tags 找到最新版本 v3.26.0，♈并点击 Source code (zip) 下载主题的源代码压缩包。\npart7: 安装与配置 Hugo 主题 (06:13-06:33) 7.1: 放置主题文件 展示下载好的主题压缩包 hugo-theme-stack-3.26.0.zip。回到本地的 Hugo 站点 dev 目录，找到 themes 文件夹。♈将下载的主题压缩包移动到 themes 文件夹内，并进行解压。\n(06:33-07:03) 7.2: 重命名主题文件夹与修改配置 解压后的主题文件夹名带有版本号 (hugo-theme-stack-3.26.0)。为了方便配置，♒将其重命名为 hugo-theme-stack。打开站点根目录下的配置文件 hugo.yaml (之前从主题的 exampleSite 复制过来的)。找到 theme 配置项，将其值修改为刚刚重命名的文件夹名 hugo-theme-stack。保存配置文件。\n(07:03-07:19) 7.3: 应用主题示例配置与内容 为了快速看到效果，作者将主题♐ exampleSite 目录下的 content 文件夹和 hugo.yaml 文件复制到站点根目录 (dev) 下，并选择覆盖现有文件。这样就♈直接使用了主题自带的示例内容和配置。\n(07:19-07:28) 7.4: 清理与重启服务 ♐删除了站点根目录下原有的 hugo.toml 文件【因为现在使用 hugo.yaml，它们是同一个配置文件，只是后缀名不同】。回到命令行窗口，停止之前运行的 Hugo 服务（通过按 Ctrl+C，虽然画面未显示），然后再次执行 hugo server -D 命令重新启动服务。\n(07:28-07:47) 7.5: 预览带主题的站点 刷新浏览器中 http://localhost:1313 页面。此时，网站成功加载了 Stack 主题和其示例内容，外观与之前展示的成品相似。\npart8: 主题示例内容处理 (07:47-08:07) 8.1: 删除 Rich Content 示例文章 在预览页面滚动时，作者提到主题♋示例中有一个名为 rich-content 的文章。因为这篇文章引用了 YouTube 等外部资源，在国内网络环境下可能导致加载超时或构建失败，所以♈建议删除。随后展示了♈在 根目录/content/post 目录下删除 rich-content 文件夹的操作。\n(08:07-08:39) 8.2: 参考主题 Demo 站 回到主题的 GitHub 仓库页面，指出 README.md 文件通常包含重要信息。找到了♋主题提供的 Demo 演示站点链接 (demo.stack.jimmycai.com) 并打开。说明可以通过访问 Demo 站点来了解 rich-content 页面原本包含哪些内容（如嵌入视频、特殊格式等）。\npart9: Hugo 国际化 (i18n) 功能说明 (08:39-09:04) 9.1: 文件名与语言代码 解释 Hugo 的国际化 (i18n) 功能。以 dev/content/post/chinese-test 文件夹为例，其中的内容文件是 index.zh-cn.md。指出文件名中的 .zh-cn 就是语言代码。对比 emoji-support 文件夹下的 index.md 文件，它没有语言代码。\n(09:04-09:19) 9.2: 国际化工作原理 说明：如果文件名不带语言代码 (如 index.md)，则该内容属于在 hugo.yaml 中配置的默认语言（此例中为英语）。♈网站会根据用户切换的语言（通过页面上的语言切换器）加载对应语言代码的文件【切出对应后缀名的文件】。例如，♈切换到中文，会加载 index.zh-cn.md；♈切换到英文，会加载 index.en.md 或默认的 index.md。 也就是当访问者在您的网站上选择或切换到中文（简体） 这个语言选项时，Hugo 会查找并使用带有 .zh-cn.md 后缀的文件来渲染该页面，比如 有一个名为 我的笔记.md 的 Markdown 文件，并且您希望它只在网站的中文环境下显示，需要将其重命名为 我的笔记.zh-cn.md (09:19-09:29) 9.3: 国际化演示 为了演示，♈将 chinese-test 文件夹下的 index.zh-cn.md 重命名为 index.en.md【就是改改后缀名而】。刷新本地预览页面。此时切换到英文环境，会显示原 \u0026ldquo;Chinese Test\u0026rdquo; 的内容；♈切换到中文环境，则该文章消失，因为对应的中文文件 (index.zh-cn.md) 已不存在。说明 Hugo 的国际化实现相对简单，只需复制文件并修改语言代码即可。\npart10: 创建与编辑新内容 (09:29-09:57) 10.1: 创建新文章命令 (hugo new content) 演示如何使用命令行创建新文章。命令格式为 hugo new content \u0026lt;section\u0026gt;/\u0026lt;slug\u0026gt;/index.md。其中 \u0026lt;section\u0026gt; 通常是 content 目录下的子目录（如 post），\u0026lt;slug\u0026gt; 是文章的唯一标识（会成为文件夹名），index.md 是内容文件名。 ♈作者执行了命令 hugo new content post/myFirstBlog/index.md，成功创建了一个名为 myFirstBlog 的文章。\n(09:57-10:15) 10.2: 编辑新文章内容 (Markdown) 使用 Typora 编辑器打开新创建的 dev/content/post/myFirstBlog/index.md 文件。文件自动包含了基础的 front matter（如 title, date, draft: true）。在文件末尾添加了一行 Markdown 内容：### Hello World!。保存文件。\n(10:15-10:31) 10.3: 预览新文章 刷新本地预览页面 (http://localhost:1313)。新创建的 \u0026ldquo;MyFirstBlog\u0026rdquo; 文章出现在首页列表。点击进入该文章，可以看到刚才添加的 \u0026ldquo;Hello World!\u0026rdquo; 标题。这表明文章已成功创建并显示。\npart11: 本地搭建完成与后续步骤 (10:31-10:38) 11.1: 本地搭建总结 至此，使用 Hugo 和 Stack 主题在本地搭建博客的基本流程已经完成。\n(10:38-10:43) 11.2: 后续内容预告 说明接下来的步骤将涉及♐修改配置 hugo.yaml【♐至于hugo.yaml有哪些配置 一般要么样式文件里面的hugo.yaml会讲在哪里找，要么样式文件里面的hugo.yaml已经把全部配置给你了】以及如何将博客部署到 GitHub Pages。\n","date":"2025-02-20T20:14:22+08:00","permalink":"https://yichixing.github.io/hugo-stack-dev/p/%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0hugo%E5%8D%9A%E5%AE%A2/","title":"搭建本地hugo博客"},{"content":"Cloudflare Pages 连接到 hugo-Fixlt-dev 仓库时，♈Cloudflare Pages 默认是直接托管该仓库中的 静态文件 ，♈它 不会 重新运行 hugo 构建命令。\n因此，♈你在 Cloudflare Pages 设置的环境变量 HUGO_BASEURL 在这个流程中 根本没有机会 被 Hugo 构建过程使用，因为它是在 Action（ hugo-main 仓库中）构建完成 之后 才接触到这些文件的。♈静态文件一旦生成，里面的绝对 URL 就已经固定了\n比如，♈GitHub Action 在构建时使用了固定的 baseURL （例如 GitHub Pages 的 URL），生成的 HTML/CSS/JS 文件中的链接都是指向这个 URL 的绝对路径。\n因此当 Cloudflare Pages 直接提供这些预先构建好的文件时，这些绝对路径对于 Cloudflare 的域名来说是错误的，导致资源加载失败\n","date":"2025-02-20T20:14:22+08:00","permalink":"https://yichixing.github.io/hugo-stack-dev/p/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8F%AA%E6%9C%89%E5%9C%A8%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9E%84%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8/","title":"环境变量只有在项目的构建的过程中使用"},{"content":"用AI独立开发MCP服务的集合 生成MCP服务 生成调用本地项目的MCP服务 httpsaistudio.google.comprompts1yTmovHhdhAThW5Fzigr_4hYlBB8GEaLM\n[1 如何AI编程开发MCP] 用AI开发MCP服务 这里用对应的提示词让AI客户端生成满足自己需求的本地MCP服务代码 （markdown格式 、简单描述MCP服务要实现的功能 、 告诉AI 本地项目的路径、 告诉AI 要激活哪个虚拟环境、 告诉AI要设置的 模型的key）、 （把本地项目的全部代码直接告诉AI、告诉AI 项目运行后的响应情况 也就是直接把终端的完整内容复制给AI，这个终端的完整内容包含程序的运行命令和项目运行效果） （ 给AI详细的MCP文档（告诉AI MCP是什么） 、 应该可以让AI生成MCP的标准配置标准配置的对应的字段和参数我还是了解的 ） 【2 案例 创建MCP服务TimeServer的提示词】\thttpsaistudio.google.comprompts1yTmovHhdhAThW5Fzigr_4hYlBB8GEaLM 提示词里面需要MCP的哪些参考资料，这里给了链接，直接在链接里面粘贴内容过来 ","date":"2025-02-20T20:14:22+08:00","permalink":"https://yichixing.github.io/hugo-stack-dev/p/%E7%94%A8ai%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91mcp%E6%9C%8D%E5%8A%A1-%E9%9B%86%E5%90%88/","title":"用AI独立开发MCP服务 集合"},{"content":"\t[action部署hugo项目的aciton程序] \u0026lt;action部署hugo项目的aciton程序的核心：让action使用hugo命令，action环境需要hugo命令执行hugo博客\u0026gt; \u0026lt;1 有参考作用的使用uses参数的action程序的写法（参考如何让AI写action程序）\u0026gt; \u0026lt;2 有参考作用的使用run字段的action程序的写法 https://aistudio.google.com/prompts/1dv1SBgRsYgFBSgYe1Dseg0dyYouTZ3_P（参考如何让AI写action程序）\u0026gt; [[[[在action环境安装项目包（hugo包）的两种做法（参考如何让AI写action程序）] 《1 uses 关键字并指定一个像 别大大佬些好的aciton 比如peaceiris/actions-hugo@v3 这样的“动作 (Action)”时，你是在委托这个预先打包好的工具去完成安装和配置 Hugo 的任务》 《2 直接用run字段亲自告诉那个临时的 Linux 系统具体怎么做才能把 Hugo 装好》 [aciton想部署hugo的核心就是用别人预先写好的东西] 《hugo官方有提供官方action动作把仓库代码下载（检出） 到当前的虚拟运行环境中，它就是actions/checkout@v4，通过uses: actions/checkout@v4: 就能使用一个预先写好的、官方提供的“动作” (Action)》 ","date":"2024-02-20T20:14:22+08:00","permalink":"https://yichixing.github.io/hugo-stack-dev/p/github-action0-action%E9%83%A8%E7%BD%B2hugo%E9%A1%B9%E7%9B%AE%E7%9A%84aciton%E7%A8%8B%E5%BA%8F-%E6%9C%80%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","title":"github action：0 action部署hugo项目的aciton程序 最基本原理"},{"content":"(08:41-10:19) 4.4: 配置 Repository Secret\n♈ 目的：将生成的 Token 安全地提供给 GitHub Actions workflow 使用。不应该直接将 Token 字符串写入 YAML 文件。 操作路径：回到♎♐存放 Hugo 源代码的仓库（即 hugo-main），进入该仓库的 Settings -\u0026gt; 左侧菜单 Security 下的 Secrets and variables -\u0026gt; Actions。 ♈操作：点击 New repository secret 按钮。 配置 Secret： Name：输入 Secret 的名称。这个名称必须与 workflow YAML 文件中 secrets. 后面引用的名称完全一致。作者在这里将其命名为 TOKEN。 Secret：将刚才复制并保存的完整 Token 字符串粘贴到这里。 保存：点击 Add secret。 ♈优点：使用 Secrets 可以隐藏敏感信息，workflow 运行时会安全地注入该值，比硬编码在代码中安全得多 [[[[[使用aciton后将分源代码仓库和静态页面仓库 ]https://aistudio.google.com/prompts/1dv1SBgRsYgFBSgYe1Dseg0dyYouTZ3_P 《《《hugo-main 仓库 (源代码仓库)，专门用来提交项目源码的仓库，以及用来运行action的仓库，不需要开启github page的功能，所以hugo-main仓库不需要公开，也不需要把静态资源上传到这仓库上》 《《《hugo-dev 仓库 (部署目标/静态页面仓库)，hugo-main运行action后生成的静态资源文件所推送到的仓库，是存放最终网站文件并对外提供访问的地方，它是自动化流程的终点/发布目标，因此我们在仓库开启github page功能》 《《《aciton中的参数 EXTERNAL_REPOSITORY: letere-gz/hugo-dev 就是用来 明确指定了main仓库部署的目标是这个dev仓库。》\n","date":"2023-02-20T20:14:22+08:00","permalink":"https://yichixing.github.io/hugo-stack-dev/p/github-action2-github-action%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%8E%9F%E7%90%86github-action%E6%98%AF%E5%B0%86%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E5%85%B6%E5%AE%83%E4%BB%93%E5%BA%93%E4%B8%8D%E6%98%AF%E9%83%A8%E7%BD%B2%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%93%E5%BA%93/","title":"github action：2 github action部署项目原理：github action是将项目部署到其它仓库，不是部署到自己的仓库"},{"content":"(00:09-00:32) 1.2: 手动部署痛点与自动化优势\n♈指出传统方式下，每次修改完文件后，都需要手动将生成的 public 文件夹上传到服务器或托管平台，这个过程比较麻烦。 ♈使用 GitHub Actions 可以实现自动化：自动帮我们生成 public 目录，并将其部署到静态页面网站（如 GitHub Pages）。 ♈优点：只需提交代码 (git push)，后续的构建和部署过程就能自动完成，方便很多。x x \u0026lt;-https://aistudio.google.com/prompts/1dv1SBgRsYgFBSgYe1Dseg0dyYouTZ3_P 《《《♐可以源码仓库和静态资源仓库分开；因为源码仓库很重要，每次项目回溯时回溯源码仓库的代码才有意义，回溯静态资源仓库的代码没意义，这意味着未来版本控制就必须要push推送源码仓库，♓但要推送源码仓库就意味着每次推送都要同时push推送源码仓库和静态资源仓库，手动维护两个独立的 Git，需再手动进行第二次推送 流程退冗余了；♐而有了action部署静态资源后，每次只需要推送最重要的源码仓库，无需做冗余的推送静态资源仓库的步骤，无需再手动进行第二次推送\u0026gt; 《♓我觉得最主要作用是源码静态资源仓库和源代码仓库分开；♐其实不要action也行，不要action就不去推送源代码仓库了，在本地只推送public静态资源即可，反正都是推送步骤不会减少 《《♐用action把部署静态资源到github page的真正价值：多人协作，多人协作时，需要所有人都遵循同样的流程，但很是有人知道我们要推送的是public静态资源，不是源码，这就导致源码把静态资源给污染了（目录混入源代码仓库会极大地污染 Git 历史）》 \u0026lt;设置好 Action 后，你甚至可以通过 GitHub 网页界面直接编辑 Markdown 文件并提交，Action 照样能完成部署，你此时甚至不需要本地安装 Hugo；因此未来你更换了本地开发机器，构建环境都是一致的，每次 Action 运行时，都是用同一个版本、同一种配置的 Hugo 工具在同一种操作系统环境下进行构建，结果更可控\u0026gt; ","date":"2023-02-20T20:14:22+08:00","permalink":"https://yichixing.github.io/hugo-stack-dev/p/github-action2-%E7%94%A8github-action%E6%8A%8A%E6%BA%90%E7%A0%81%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0github-page%E4%BB%93%E5%BA%93%E7%9A%84%E7%9C%9F%E6%AD%A3%E6%84%8F%E4%B9%89/","title":"github action：2 用github action把源码仓库部署项目到github page仓库的真正意义"},{"content":"github aciton配置文件如何创建\n(2 action配置文件用aciton模板的配置文件， action模板配置文件扔给AI，说明需要这个action模板运行哪个脚本，让AI修改即可，因为有些时候 AI直接生成的action配置文件aciton根本运行不了) ","date":"2023-02-20T20:14:22+08:00","permalink":"https://yichixing.github.io/hugo-stack-dev/p/github-action3-ai%E7%BC%96%E5%86%99action%E7%A8%8B%E5%BA%8F%E6%8A%80%E5%B7%A7/","title":"github action：3 AI编写action程序技巧"},{"content":"(01:24-02:04) 2.4: 配置 .gitignore 忽略生成文件\n说明：Hugo 项目中的某些文件/目录是自动生成的，不应该提交到源代码仓库，包括： public/：Hugo 生成的静态网站文件目录。 resources/：Hugo 处理后的资源缓存目录。 hugo.build.lock：构建锁文件。 hugo.exe：（如果在 Windows 下）Hugo 可执行文件本身。 ♈ 操作：在本地 Hugo 项目根目录下，创建一个名为 .gitignore 的文件。 ♈操作：编辑 .gitignore 文件，将上述需要忽略的文件名或目录名（如 public, resources, hugo.build.lock, hugo.exe）添加进去，每行一个。 ♈目的：保证上传到 GitHub 的是最干净、最原始的 Hugo 项目文件。 《♓目的就是不要让静态资源污染源码，因为hugo-main是源代码仓库，源代码仓库不负责展示github page，只负责运行action得到静态资源给其它部署仓库hugo-dev，所以没必要把多余的静态资源上传到hugo-main，反正在hugo-main展示这些静态资源》 \u0026lt;git add .：添加所有文件到暂存区（♎.gitignore 会生效，忽略指定文件）。\u0026gt; ","date":"2023-02-20T20:14:22+08:00","permalink":"https://yichixing.github.io/hugo-stack-dev/p/github%E9%85%8D%E7%BD%AE1-%E4%BD%BF%E7%94%A8.gitignore%E7%9A%84%E6%84%8F%E4%B9%89/","title":"github配置：1 使用.gitignore的意义"},{"content":"[0 检查当前分支的跟踪关系] \u0026lt;命令：git status；因为如果追踪错误，那么我想要push推送到我想要的分支很可能失败，因为追踪错误的缘故，pull的是其它的分支，因此我想要的分支就没法push了\u0026gt;\n[1 取消本地 main 分支对 所有分支 的跟踪] \u0026lt;命令：git branch \u0026ndash;unset-upstream\u0026gt;\n[[[[2 指定pull拉取main的分支（为了push到main，只能强制指定要拉取main分支）] 《命令：git pull origin main》\n[[[[3 pull拉取了main分支后 就能push推送到main分支了] \u0026lt;命令：git push -u origin main\u0026gt;\n","date":"2023-02-20T20:14:22+08:00","permalink":"https://yichixing.github.io/hugo-stack-dev/p/github%E9%85%8D%E7%BD%AE2-github-pull-%E4%B8%8E-github-pushpull%E5%AF%B9%E5%88%86%E6%94%AF%E5%90%8E%E6%89%8D%E8%83%BD%E7%94%A8push/","title":"github配置：2 github pull 与 github push，pull对分支后才能用push"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://yichixing.github.io/hugo-stack-dev/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://yichixing.github.io/hugo-stack-dev/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"","date":"2019-03-11T00:00:00Z","permalink":"https://yichixing.github.io/hugo-stack-dev/p/%E5%8D%87%E7%BA%A7%E7%89%88%E6%A8%A1%E6%9D%BF/","title":"升级版模板"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://yichixing.github.io/hugo-stack-dev/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://yichixing.github.io/hugo-stack-dev/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://yichixing.github.io/hugo-stack-dev/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://yichixing.github.io/hugo-stack-dev/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://yichixing.github.io/hugo-stack-dev/p/emoji-support/","title":"Emoji Support"}]